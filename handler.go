package docshandler

import (
	"bytes"
	"embed"
	"encoding/json"
	"fmt"
	"io/fs"
	"mime"
	"net/http"
	"path/filepath"
	"strings"

	"github.com/curioswitch/go-docs-handler/specification"
)

//go:embed docsclient
var docsClient embed.FS

// New returns a new http.Handler which serves documentation generated by the given plugin.
// See Option for available configuration settings for the handler. If additional plugins are
// specified using WithAdditionalPlugin, their documentation will be shallowly merged.
func New(plugin Plugin, opts ...Option) (http.Handler, error) {
	c := newConfig(plugin)
	for _, opt := range opts {
		opt(c)
	}

	mux := http.NewServeMux()

	spec, err := c.plugins[0].GenerateSpecification()
	if err != nil {
		return nil, err
	}
	for _, p := range c.plugins[1:] {
		spec2, err := p.GenerateSpecification()
		if err != nil {
			return nil, err
		}
		mergeInSpecifications(spec, spec2)
	}

	specJSON, err := json.Marshal(spec)
	if err != nil {
		return nil, fmt.Errorf("serializing spec: %w", err)
	}

	schemasJSON, err := json.Marshal(generateJSONSchema(spec))
	if err != nil {
		return nil, fmt.Errorf("serializing schemas: %w", err)
	}

	mux.Handle("/specification.json", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		_, _ = w.Write(specJSON)
	}))

	mux.Handle("/schemas.json", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		_, _ = w.Write(schemasJSON)
	}))

	mux.Handle("/versions.json", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// TODO: Consider allowing users to provide this.
		w.Header().Set("Content-Type", "application/json")
		_, _ = w.Write([]byte("[]"))
	}))

	mux.Handle("/injected.js", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/javascript")
		w.WriteHeader(200)
		if len(c.injectedScriptSuppliers) > 0 {
			var res bytes.Buffer
			for _, ss := range c.injectedScriptSuppliers {
				res.WriteString(ss())
				res.WriteByte('\n')
			}
			_, _ = w.Write(res.Bytes()[:res.Len()-1]) // Trim trailing newline
		}
	}))

	for _, p := range c.plugins {
		type hasHandler interface {
			AddToHandler(handler *http.ServeMux)
		}
		if h, ok := p.(hasHandler); ok {
			h.AddToHandler(mux)
		}
	}

	docsClientFS, _ := fs.Sub(docsClient, "docsclient")
	filesHandler := http.FileServer(http.FS(docsClientFS))

	mux.Handle("/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/" {
			r.URL.Path = "index.html"
		}
		if r.URL.Path != "/assets/favicon.png" && !strings.HasSuffix(r.URL.Path, ".ttf") {
			w.Header().Set("Content-Type", mime.TypeByExtension(filepath.Ext(r.URL.Path)))
			r.URL.Path += ".gz"
			w.Header().Set("Content-Encoding", "gzip")
		}

		filesHandler.ServeHTTP(w, r)
	}))

	return mux, nil
}

func mergeInSpecifications(base *specification.Specification, spec *specification.Specification) {
	base.Services = append(base.Services, spec.Services...)
	base.Structs = append(base.Structs, spec.Structs...)
	base.Enums = append(base.Enums, spec.Enums...)
}
